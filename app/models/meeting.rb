class Meeting < ActiveRecord::Base
  has_many :meeting_members
  has_many :members, through: :meeting_members

  attr_accessible :member_ids
  accepts_nested_attributes_for :members

  # put everyone in a group, draw connections as edges
  # rank by edges
  # pick first by rank
  # pick second by rank that isn't connected to first
  # pick third by rank that isn't connected to either first or second
  def self.schedule_all
    ranks = Hash[Member.all.map do |member|
      edges = member.edges
      [member.id, {edges: edges, num_edges: edges.count}]
    end]

    until ranks.empty?
      meeting_member_ids = []
      forbidden_member_ids = []
      until meeting_member_ids.length == 3
        pair = delete_max_rank(forbidden_member_ids, ranks)
        next if pair.nil?
        meeting_member_ids << pair.first
        forbidden_member_ids << pair.last[:edges]
      end
      Meeting.create(member_ids: meeting_member_ids)
    end
  end

  # mutates ranks!
  def delete_max_rank(restricted_ids_arr, rem_ranks)
    rem_ranks_copy = rem_ranks.dup
    restricted_ids_arr.each { |r_id| rem_ranks_copy.delete(r_id) }

    if rem_ranks_copy.empty?
      nil
    else
      p_id, p_h = rem_ranks_copy.max_by do |id, h|
        if restricted_ids_arr.include?(id)
          next
        else
          h[:num_edges]
        end
      end
      rem_ranks.delete(p_id)
      [p_id, p_h]
    end
  end
end
#--
# generated by 'annotated-rails' gem, please do not remove this line and content below, instead use `bundle exec annotate-rails -d` command
#++
# Table name: meetings
#
# * id           :integer         not null
#   meeting_date :date
#   created_at   :datetime
#   updated_at   :datetime
#--
# generated by 'annotated-rails' gem, please do not remove this line and content above, instead use `bundle exec annotate-rails -d` command
#++
